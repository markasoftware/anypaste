#!/usr/bin/env bash

# This is anypaste. Authored by Mark Polyakov (see markasoftware.com)
# This software is released under the GPLv3, see gnu.org
# Homepage at anypaste.xyz

# shellcheck disable=2128

ap_version='1.0.3'
[[ $OSTYPE == darwin* ]] && ap_mac='true' || ap_mac='false'

# BEGIN PLUGINS

# COMMON PLUGIN FUNCTIONS

function check_size {
	if ! [[ $(wc -c < "$ap_path") -lt $1 ]]
	then
		echo "WARNING: File is of compatible type for plugin '$ap_plugin', but is above size limit of $1 bytes" >&2
		return 1
	fi
}

function curl_form_upload {
	curl -#fF "$1=@\"$ap_path\";type=$ap_mime" "$2" || { echo 'ERROR: Upload request did not return HTTP 200!' >&2 && return 1; }
}

function curl_file_upload {
	curl "-X$1" -#fT "$2" "$3" || { echo 'ERROR: Upload request did not return HTTP 200!' >&2 && return 1; }
}

# string json, string key -> string value
# make sure no special chars in key, and key can't appear in json before it appears as a key
# also make sure top_sekrit isn't in the input. Don't try this at home, kids!
function json_parse {
	# shellcheck disable=1117
	echo "$1" | sed -E "s/$2/top_sekrit/;s/.*\"top_sekrit\" *: *\"?//;s/\"?(,|}).*//;s/\\\//g"
}

# PLUGINS

function ixio {
	case $1 in
	check_eligibility)
		[[ $ap_mime == text/* ]]
		;;
	upload)
		ixio_link=$(curl_form_upload 'f:1' ix.io) || return 1
		echo >&2
		echo "Direct: $ixio_link"
		echo
		;;
	esac
}

function hastebin {
	case $1 in
	check_eligibility)
		[[ $ap_mime == text/* ]]
		;;
	upload)
		hastebin_json=$(curl_file_upload 'POST' "$ap_path" 'https://hastebin.com/documents') || return 1
		hastebin_id=$(json_parse "$hastebin_json" 'key')
		echo 'Reminder: hastebin.com uploads are deleted 30 days after their last view!' >&2
		echo >&2
		echo "Link: https://hastebin.com/$hastebin_id"
		echo "Direct: https://hastebin.com/raw/$hastebin_id"
		echo
	esac
}

function fileio {
	case $1 in
	check_eligibility)
		check_size 5000000000
		;;
	upload)
		fileio_json=$(curl_form_upload 'file' 'https://file.io') || return 1
		fileio_link=$(json_parse "$fileio_json" 'link')
		echo 'Reminder: file.io uploads are deleted after being download, or 14 days, whichever comes first!' >&2
		echo >&2
		echo "Direct: $fileio_link"
		echo
		;;
	esac
}

function transfersh {
	case $1 in
	check_eligibility)
		check_size 10000000000
		;;
	upload)
		# TODO: if we ever add support for custom parameters for plugins, then have custom filename here!
		transfersh_link=$(curl_file_upload 'PUT' "$ap_path" "https://transfer.sh/$ap_human_name") || return 1
		echo 'Reminder: transfer.sh uploads are deleted after 14 days!' >&2
		echo 'Transfer.sh links are *not* direct if you use a browser, but they can be curled!';
		echo >&2
		echo "Direct: $transfersh_link"
		echo
		;;
	esac
}

function vgyme {
	case $1 in
	check_eligibility)
		# This is literally the worst possible way to design how the quotes should be used in a regex
		[[ $ap_mime =~ 'image/jpeg'|'image/png'|'image/gif'|'image/x-ms-bmp' ]] && check_size 20000000
		;;
	upload)
		vgyme_json=$(curl_form_upload 'file' 'https://vgy.me/upload') || return 1
		vgyme_link=$(json_parse "$vgyme_json" 'url')
		vgyme_direct=$(json_parse "$vgyme_json" 'image')
		vgyme_delete=$(json_parse "$vgyme_json" 'delete')
		echo >&2
		echo "Link: $vgyme_link"
		echo "Direct: $vgyme_direct"
		echo "Delete: $vgyme_delete"
		echo
		;;
	esac
}

function tinyimg {
	case $1 in
	check_eligibility)
		[[ $ap_mime == image/* ]] && check_size 10000000
		;;
	upload)
		tinyimg_json=$(curl_form_upload 'qqfile' 'https://tinyimg.io/upload') || return 1
		tinyimg_filename=$(json_parse "$tinyimg_json" 'uploadName')
		echo >&2
		echo "Direct: https://tinyimg.io/i/$tinyimg_filename"
		echo
		;;
	esac
}

function imgur {
	case $1 in
	check_eligibility)
		[[ $ap_mime == image/* ]] && check_size 100000000
		;;
	upload)
		imgur_json=$(curl -#fF "image=@\"$ap_path\"" -F "name=\"$ap_human_name\"" \
			-H "Authorization: Client-ID ${imgur_client_id:-c7e65b324a5ebe8}" \
			'https://api.imgur.com/3/image') || return 1
		imgur_id=$(json_parse "$imgur_json" 'id')
		imgur_link=$(json_parse "$imgur_json" 'link')
		imgur_deletehash=$(json_parse "$imgur_json" 'deletehash')
		echo >&2
		echo "Link: https://imgur.com/$imgur_id"
		echo "Direct: $imgur_link"
		echo "Edit: https://imgur.com/edit?deletehash=$imgur_deletehash"
		echo "Delete: https://imgur.com/delete/$imgur_deletehash"
		echo
	esac
}

function instaudio {
	case $1 in
	check_eligibility)
		[[ $ap_mime =~ 'audio/x-wav'|'audio/mpeg'|'audio/ogg' ]] && check_size 15000000
		;;
	upload)
		inst_json=$(curl_form_upload 'audio_file' 'https://instaud.io/new.json') || return 1
		inst_redirect=$(json_parse "$inst_json" 'redirect_url')
		# this is POSIX compliant, I guess
		ap_ext="${ap_path##*.}"
		echo >&2
		echo "Link: https://instaud.io$inst_redirect"
		echo "Direct: https://instaud.io/_$inst_redirect.$ap_ext"
		echo
		;;
	esac
}

function clyp {
	case $1 in
	check_eligibility)
		[[ $ap_mime =~ 'audio/x-wav'|'audio/mpeg'|'audio/ogg'|'audio/x-aiff'|'audio/x-m4a' ]] || return 1
		check_size 5000000
		;;
	upload)
		clyp_json=$(curl -#fF "audioFile=@\"$ap_path\"" -H 'X-Client-Type: WebAlfa' \
			https://upload.clyp.it/upload) || return 1
		clyp_link=$(json_parse "$clyp_json" 'Url')
		clyp_mp3_direct_link=$(json_parse "$clyp_json" 'SecureMp3Url')
		echo >&2
		echo "Link: $clyp_link"
		echo "Direct: $clyp_mp3_direct_link"
		echo
		;;
	esac
}

function streamable {
	case $1 in
	check_eligibility)
		[[ $ap_mime =~ 'video/'|'image/gif' ]] && check_size 10000000000
		;;
	get_required_config)
		echo 'streamable_email'
		echo 'streamable_password'
		;;
	upload)
		# shellcheck disable=2154
		streamable_json=$(curl -#fu "$streamable_email:$streamable_password" -F "file=@$ap_path" https://api.streamable.com/upload) || return 1
		streamable_shortcode=$(json_parse "$streamable_json" 'shortcode')
		echo >&2
		echo "Link: https://streamable.com/$streamable_shortcode"
		echo
		;;
	esac
}

function sendvid {
	case $1 in
	check_eligibility)
		[[ $ap_mime == video/* ]] && check_size 1000000000
		;;
	upload)
		# Sendvid won't upload videos with certain file extensions, but will still encode them
		# and function properly if uploaded as a .mp4
		# Maybe time for them to switch to mime type checking?
		sendvid_json=$(curl -#fF "video=@$ap_path;filename=${ap_human_name%.*}.mp4" http://sendvid.com/api/v1/videos) || return 1
		sendvid_pub=$(json_parse "$sendvid_json" 'slug')
		sendvid_priv=$(json_parse "$sendvid_json" 'secret')
		echo >&2
		echo "Link: https://sendvid.com/$sendvid_pub"
		echo "Delete/Edit: https://sendvid.com/$sendvid_pub?secret=$sendvid_priv"
		echo
		;;
	esac
}

function gfycat {
	case $1 in
		check_eligibility)
			# I'm not sure why shellcheck is angry about this
			# shellcheck disable=2140
			[[ $ap_mime =~ "video/"|"image/gif" ]]
			;;
		upload)
			# this is one of the more complex ones
			# get the key/name of the gfy
			# shellcheck disable=2154
			if [[ -n "$gfycat_duplicates" ]]
			then
				gfy_init_json=$(curl -sfXPOST https://api.gfycat.com/v1/gfycats) || {
					echo 'Getting gfycat key did not return HTTP 200!' >&2
					return 1;
				}
			else
				gfy_init_json=$(curl -sfXPOST -H 'Content-Type: application/json' -d '{"noMd5":"true"}' https://api.gfycat.com/v1/gfycats) || {
					echo 'Getting gfycat key did not return HTTP 200!' >&2
					return 1;
				}
			fi
			gfy_name=$(json_parse "$gfy_init_json" 'gfyname')
			# the file being uploaded must have the same name as the key
			# since i don't know how to set it using curl options, I'm
			# just using a symbolic link with the correct name.
			ln -s "$ap_path" "/tmp/$gfy_name"
			curl_file_upload 'PUT' "/tmp/$gfy_name" 'https://filedrop.gfycat.com' > /dev/null || return 1
			rm -f "/tmp/$gfy_name"
			if [[ -n "$gfycat_duplicates" ]]
			then
				# We have to wait for encoding (unlike with streamable) because
				# during encoding, if it has the same hash as another gfy, it
				# returns the (different) link to the original gfy, and the new
				# one won't work. It's possible to override this to upload with
				# the new URL regardless, but i don't need to use up extra space
				# on the gfycat servers.
				echo 'Waiting for remote encoding to complete...' >&2
				while true
				do
					sleep 4
					gfy_status=$(curl -fs "https://api.gfycat.com/v1/gfycats/fetch/status/$gfy_name") || {
						echo 'Status check request did not return HTTP 200!' >&2
						echo "Your file might end up here anyway: https://gfycat.com/$gfy_name" >&2
						return 1;
					}
					[[ $gfy_status == *complete* ]] && break
				done
				[[ $gfy_status == *gfyName* ]] && \
					gfy_final_name=$(json_parse "$gfy_status" 'gfyName') || \
					gfy_final_name=$(json_parse "$gfy_status" 'gfyname')
			else
				gfy_final_name="$gfy_name"
				echo 'Reminder: Gfycat needs time to encode. Your video will not appear right away.' >&2
			fi
			echo >&2
			echo "Link: https://gfycat.com/$gfy_final_name"
			echo "Direct: https://thumbs.gfycat.com/$gfy_final_name-size_restricted.gif"
			echo
	esac
}

function docdroid {
	case $1 in
	get_required_config)
		echo 'docdroid_access_token'
		;;
	check_eligibility)
		[[ $ap_mime =~ 'application/pdf'|'application/msword'|'application/vnd.openxmlformats-officedocument'|'application/vnd.ms'|'application/vnd.oasis.opendocument'|'text/rtf' ]]
		;;
	upload)
		# shellcheck disable=2154
		docdroid_json=$(curl -H "Authorization: Bearer $docdroid_access_token" -#fF "file=@$ap_path" https://docdroid.net/api/document)
		docdroid_id=$(json_parse "$docdroid_json" 'id')
		docdroid_filename=$(json_parse "$docdroid_json" 'filename')
		echo >&2
		echo "Link: http://docdro.id/$docdroid_id"
		echo "Direct: https://www.docdroid.net/file/download/$docdroid_id/$docdroid_filename"
		echo
		;;
	esac
}

function pomf {
	case $1 in
	check_eligibility)
		# that's right, 5gb motherfuckers
		check_size 5120000000
		;;
	upload)
		pomf_json=$(curl_form_upload 'files[]' "${pomf_upload_url:-https://dmca.gripe/api/upload}") || return 1
		pomf_json=$(tr -d \\n <<< "$pomf_json")
		pomf_link=$(json_parse "$pomf_json" 'url')
		echo >&2
		echo "Direct: $pomf_link"
		echo
		;;
	esac
}

#################
## END PLUGINS ##
## BEGIN CORE ###
#################

# HOOKS

function ap_copy_hook {
	# -m isn't POSIX :(
	ap_copy_me=$(grep -E "${ap_copy_regex:-.}" <<< "$ap_last_stdout" | head -n 1)
	ap_copy_me="${ap_copy_me##*: }"
	if $ap_mac
	then
		pbcopy "$ap_copy_me"
	elif command -v xsel >/dev/null
	then
		echo -n "$ap_copy_me" | xsel -ib
	elif command -v xclip >/dev/null
	then
		echo -n "$ap_copy_me" | xclip -selection clipboard
	else
		echo 'WARNING: no suitable program to copy text was found on your system. Please report a bug!'
	fi
}

function ap_notify_hook {
	ap_notification_text="Anypaste upload complete: $ap_human_name"
	if $ap_mac
	then
		# hahahaha motherfuckers
		say "$ap_notification_text"
		osascript -e "display notification \"$ap_notification_text\""
	else
		command -v notify-send >/dev/null && notify-send "$ap_notification_text" || \
			echo 'WARNING: Install notify-send if you want --notify to work.'
	fi
}

# FUNCTIONS

# exit safely, remove temporary files if any
ap_tmp_files=('/tmp/ap_stdout')
function ap_exit {
	[[ ${#ap_tmp_files[@]} -gt 0 ]] && rm -f "${ap_tmp_files[@]}"
	[[ -n $1 ]] && exit "$1" || exit
}

# Y is always default. Word your questions better. Be positive!
# args: message
function ap_i_yn {
	echo -n "$1 [Y/n] " >&2
	read -r ap_attempt
	[[ "$ap_attempt" != 'n' && "$ap_attempt" != 'N' ]]
}

# will search $ap_compatible_plugins for search term. If successful, matched plugin
# will go in $ap_plugin. If failed, it will print an error and return 1
# Also, if search term is the exact name of an executable, it will be ok if ap_x
# args: search term
function search_compatible_plugins {
	# If empty, use first plugin
	[[ -z "$1" ]] && ap_plugin="${ap_compatible_plugins[@]:0:1}" && return
	# If the plugin is the exact name of a command, we can use it even if not in config
	$ap_x && command -v "$1" > /dev/null && ap_plugin="$1" && return
	ap_matched_plugins=()
	for ap_plugin in "${ap_compatible_plugins[@]}"
	do
		[[ $ap_plugin == *$1* ]] && ap_matched_plugins+=("$ap_plugin")
	done
	case ${#ap_matched_plugins[@]} in
	0)
		echo "No plugins matched '$1'." >&2
		echo -n 'Available plugins are:' >&2
		printf " '%s'" "${ap_compatible_plugins[@]}" >&2
		echo >&2
		return 1
		;;
	1)
		ap_plugin="${ap_matched_plugins[@]:0:1}"
		;;
	*)
		echo -n "Multiple plugins matched '$1':" >&2
		printf " '%s'" "${ap_matched_plugins[@]}" >&2
		echo >&2
		echo 'Refine your search and try again.' >&2
		return 1
		;;
	esac
}

function ap_i_select_plugin {
	# fail if no plugins
	[[ ${#ap_compatible_plugins[@]} -eq 0 ]] && return 1
	if [[ ${#ap_compatible_plugins[@]} -eq 1 ]] 
	then
		echo "Only one compatible plugin was found: $ap_compatible_plugins" >&2
		ap_plugin="$ap_compatible_plugins"
	fi
	echo -n 'The following plugins were found:' >&2
	printf " '%s'" "${ap_compatible_plugins[@]}" >&2
	echo >&2
	# keep asking for search terms until we find something
	while true
	do
		echo >&2
		echo 'Enter the (partial) name of a plugin, or nothing for automatic selection' >&2
		read -r ap_search_term
		search_compatible_plugins "$ap_search_term" && break
	done
}

#shellcheck disable=2016
ap_help='
Usage: anypaste [-ifh] [-p plugin] [-c config_file_path] [file1 [file2 ...]]

Upload `file`s or stdin to an automatically selected hosting sites.
You can specify `-` as a file to read from stdin. If no files are
listed, it will automatically attempt to use stdin.

OPTIONS:

 -i          Enable interactive mode. Will prompt for important options.
             Combining this with options intended for non-interactive
             use (e.g, -p) has undefined behavior. If you are reading
             your file from stdin, -i might not work properly.
 -p          Specify a plugin instead of automatic selection. Uses fuzzy
             matching (e.g, `gfy` search will match `gfycat` plugin).
             Only searches compatible plugins by default.
 -n          Specify the name that will be displayed on the site. Not
             universally supported. Defaults to file basename.
 -s          Silence everything but links (equivalent to 2>/dev/null)
 -c          Use the specified configuration file instead of the default
             one located at $XDG_CONFIG_HOME/anypaste.conf
 -C          Create a default configuration file. This is how you should
             initialize a config file if you want to use one.
 -f          Do not check plugin compatibility. Without -p, it uses the
             first listed plugin in the config file. Primary meant for
             use with -p
 -x          If plugin specified using -p or interactive mode is the
             exact name of an executable, it will be used, even if it is
             not listed in the configuration file.
 -v          Display Anypaste version
 -h, --help  Display this help text.

Plugins may support additional options not listed here.
'

# PARSE CLI OPTIONS

ap_i='false'
ap_f='false'
ap_x='false'
ap_C='false'
ap_p=""
ap_cfg=""
ap_copy='false'
ap_notify='false'

ap_args=("$@")

# janky long option finder, because we can't use GNU getopt. Fuck mac. Wait, did I already say that?
for i in "${!ap_args[@]}"
do
	ap_found_long_opt=true
	case "${ap_args[$i]}" in
		'--help')
			echo "$ap_help"
			ap_exit
			;;
		'--version')
			echo "Anypaste $ap_version"
			ap_exit
			;;
		'--copy') ap_copy=true;;
		'--notify') ap_notify=true;;
		*) ap_found_long_opt=false;;
	esac
	$ap_found_long_opt && unset "ap_args[$i]"
done

# This is necessary to make the pseudo-shift with OPTIND work later
ap_args=("${ap_args[@]}")

# the - is so that it ignores long options without error
# Shellcheck actually checks specifically for getopts options in the case. How cool is that?
# shellcheck disable=2213
while getopts 'C-vxfhsip:c:n:' ap_opt "${ap_args[@]}"
do
	# shellcheck disable=2220
	case $ap_opt in
	h)
		echo "$ap_help"
		ap_exit
		;;
	i)
		ap_i='true'
		;;
	p)
		ap_p="$OPTARG"
		;;
	f)
		ap_f='true'
		;;
	x)
		ap_x='true'
		;;
	c)
		ap_cfg="$OPTARG"
		;;
	C)
		ap_C='true';
		;;
	v)
		echo "Anypaste $ap_version"
		ap_exit
		;;
	n)
		ap_human_name="$OPTARG"
		;;
	s)
		exec 2>/dev/null
		;;
	esac
done

ap_args=("${ap_args[@]:$((OPTIND-1))}")

# CREATE CONFIGURATION

# determine path to configuration file
# todo: allow command-line specified configuration file

if [[ -z "$ap_cfg" ]]
then
	if $ap_mac
	then
		# fuck mac users, they deserve random config files in their home directory because there's nowhere defined to put them
		ap_cfg="$HOME/.anypaste.conf"
	else
		[[ -n "$XDG_CONFIG_HOME" ]] && ap_cfg="$XDG_CONFIG_HOME/anypaste.conf" || ap_cfg="$HOME/.config/anypaste.conf"
	fi
fi

if $ap_C
then
	cat > "$ap_cfg" << 'CFG'
# List of plugins
# If there are multiple compatible plugins, precedence is determined
# by which one is listed first in this array
# You'll need to uncomment (remove # at beginning of line) first
# ap_plugins=(
# 'sendvid' 'streamable' 'gfycat' # Videos/Gifs
# 'tinyimg' 'imgur' 'vgyme' # Images
# 'instaudio' 'clyp' # Audio
# 'hastebin' 'ixio' # Text
# 'docdroid' # Documents
# 'pomf' 'transfersh' 'fileio' # Generic
# )

# Make sure to use export `boop=whatever` for plugin settings, not just `boop=whatever`
# Otherwise plugins won't be able to see your variables.

# SETTINGS FOR DEFAULT PLUGINS
# remember to uncomment them for them to work

# Set both of these to a real account to enable the streamable plugin
# export streamable_email=mark@example.com
# export streamable_password=hunter2

# Create a docdroid.net account, go to settings, and create an API access token
# export docdroid_access_token=928doebknb80fd38rduroenaudhoenkb283d8pf7230upf8rekb92

# Set this to anything to enable duplicate-checking on Gfycat. See anypaste documentation
# for more details.
# export gfycat_duplicates="yes"
CFG
	echo "Created configuration file at $ap_cfg" >&2
	echo 'It does nothing by default, edit it to make it cool!' >&2
	ap_exit
fi

export PATH="$HOME/.anypaste-plugins:$PATH"

# LOAD AND CHECK CONFIGURATION

# default plugins
ap_plugins=(
	'sendvid' 'streamable' 'gfycat' 'tinyimg' 'imgur' 'vgyme' 'instaudio' 'hastebin' 'ixio' 'docdroid' 'pomf' 'transfersh' 'fileio'
)
ap_hooks=()

# this could fail if no config file, hence why 2> /dev/null
# shellcheck disable=1090
source "$ap_cfg" 2> /dev/null

[[ ${#ap_plugins[@]} == 0 ]] && echo 'No plugins listed in config!' && ap_exit 100

$ap_copy && ap_hooks+=('ap_copy_hook')
$ap_notify && ap_hooks+=('ap_notify_hook')

# CHECK CONFIGURATION PARAMETERS FUNCTION

function check_eligibility {
	command -v "$ap_plugin" > /dev/null || { echo "WARNING: Plugin $ap_plugin could not be found! You may need to check your config file." >&2 && return 1; }
	$ap_plugin check_eligibility || return 1
	missing_configs=()
	for cur_req_config in $($ap_plugin get_required_config)
	do
		if [[ -z "${!cur_req_config}" ]]
		then
			missing_configs+=("$cur_req_config")
		fi
	done
	if [[ ${#missing_configs[@]} -gt 0 ]]
	then
		echo -n "Plugin '$ap_plugin' is compatible, but missing config parameters:" >&2
		printf " '%s'" "${missing_configs[@]}" >&2
		echo >&2
		echo "You can set them in $ap_cfg" >&2
		return 1
	fi
}

function run_hooks {
	for i in "${ap_hooks[@]}"
	do
		$i
	done
}

function upload_plugin {
	echo "Attempting to upload with plugin '$ap_plugin'" >&2
	export ap_last_stdout
	if $ap_plugin upload | tee /tmp/ap_stdout_cache
	then
		ap_last_stdout=$(</tmp/ap_stdout_cache)
		# shellcheck disable=2154
		[[ $ap_hook_policy == greedy ]] && run_hooks
		echo 'Upload complete.' >&2
	else
		echo "Plugin failed with error code $?" >&2
		return 1 
	fi
}

# LOOP THROUGH PLUGINS

# args: whether to check compatibility
function find_plugins {
	$1 && ap_compatible_plugins=("${ap_plugins[@]}") && return
	ap_compatible_plugins=()
	for ap_plugin in "${ap_plugins[@]}"
	do
		check_eligibility && ap_compatible_plugins+=("$ap_plugin")
	done
}

function upload_loop {
	echo "Current file: $ap_user_path" >&2
	if $ap_i
	then
		# INTERACTIVE
		ap_i_yn 'Determine compatible plugins automatically?' && ap_skip_compat='false' || ap_skip_compat='true'
		find_plugins $ap_skip_compat
		# keep looping and selecting plugins, removing the previously attempted plugin each time, until we succeed
		# or there are none left
		while true
		do
			ap_i_select_plugin || return 1
			ap_i_yn "Attempt to upload with plugin '$ap_plugin'?" >&2 || continue
			upload_plugin && break
			# we have to use unset to remove the selected one, but it only
			# takes an index :(
			for i in "${!ap_compatible_plugins[@]}"
			do
				if [[ ${ap_compatible_plugins[$i]} == "$ap_plugin" ]]
				then
					unset "ap_compatible_plugins[$i]"
					ap_compatible_plugins=("${ap_compatible_plugins[@]}")
					break
				fi
			done
		done
	else
		# NON-INTERACTIVE
		if [[ -n "$ap_p" ]]
		then
			find_plugins "$ap_f"
			search_compatible_plugins "$ap_p" || return 1
			upload_plugin && return
		else
			find_plugins "$ap_f"
			for ap_plugin in "${ap_compatible_plugins[@]}"
			do
				upload_plugin && return
			done
			echo 'No compatible plugins found, or all compatible plugins failed.' >&2
			return 1
		fi
	fi
}

function ap_rand_tmp {
	ap_rand_str=$(head -c 20 /dev/urandom | base64 | tr -dc 0-9A-Za-z)
	echo "/tmp/anypaste-$ap_rand_str"
}
ap_found_stdin='false'
# NO FILES SPECIFIED
if [[ ${#ap_args[@]} == 0 ]]
then
	if [[ -t 0 ]]
	then
		echo 'ERROR: No files specified, and stdin is a terminal' >&2
		# we put this to stderr despite putting help text on stdout when
		# -h or --help is passed because a program might not expect it here
		echo "$ap_help" >&2
		ap_exit 102
	fi
	ap_args=('-')
fi
# LOOP THROUGH FILES
ap_ok_uls=()
ap_fail_uls=()
function ap_failed_ul {
	ap_fail_uls+=("$ap_user_path")
}
for ap_user_path in "${ap_args[@]}"
do
	# HANDLE WEIRD FILES

	# STDIN
	if [[ $ap_user_path == '-' ]]
	then
		if $ap_found_stdin
		then
			echo 'You specified stdin more than once!' >&2
			echo 'All but the first will be ignored.' >&2
			ap_failed_ul
			continue
		fi
		if [[ -t 0 ]]
		then
			echo 'Stdin specified, but stdin is a terminal!' >&2
			continue
		fi
		ap_path=$(ap_rand_tmp)
		ap_tmp_files+=("$ap_path")
		cat > "$ap_path"
		ap_found_stdin='true'
	# NOT READABLE
	elif [[ ! -r "$ap_user_path" ]]
	then
		echo "$ap_user_path is not readable!" >&2
		echo 'Make sure it exists and you have proper permissions for it.' >&2
		ap_exit_code=101
		ap_failed_ul
		continue
	# IS A DIRECTORY
	elif [[ -d "$ap_user_path" ]]
	then
		echo "$ap_user_path is a directory, creating tarball..." >&2
		ap_path="$(ap_rand_tmp).tar.gz"
		ap_tmp_files+=("$ap_path")
		tar czf "$ap_path" -C "$ap_user_path" .
	# NOTHING SPECIAL
	else
		ap_dirname=$(dirname "$ap_user_path")
		ap_basename=$(basename "$ap_user_path")
		# I'm not convinced we need the || cases here, but shellcheck is.
		pushd "$ap_dirname" >/dev/null || ap_exit 1
		ap_path="$PWD/$ap_basename"
		popd >/dev/null || ap_exit 1
	fi
	export ap_path
	ap_mime=$(file --mime-type --brief "$ap_path")
	export ap_mime
	# TODO: maybe don't call it human name? confusing with user name
	export ap_human_name=${ap_human_name:-$(basename "$ap_path")}
	if upload_loop
	then
		ap_ok_uls+=("$ap_user_path")
	else
		ap_exit_code=100
		ap_failed_ul
	fi
done

# SUMMARY if multiple files uploaded
if [[ $((${#ap_ok_uls[@]} + ${#ap_fail_uls[@]})) -gt 1 ]]
then
	# SUCCESSES
	echo -en '\nSucessfully uploaded:' >&2
	if [[ ${#ap_ok_uls[@]} -gt 0 ]]
	then
		printf " '%s'" "${ap_ok_uls[@]}" >&2 || echo -n ' None' >&2
		[[ $ap_hook_policy != greedy ]] && run_hooks
	fi

	echo >&2

	# FAILURES
	if [[ ${#ap_fail_uls[@]} -gt 0 ]]
	then
		echo -n 'Failed to upload:' >&2
		printf " '%s'" "${ap_fail_uls[@]}" >&2
		echo >&2
		[[ ${#ap_ok_uls[@]} -gt 0 ]] && ((ap_exit_code+=100))
	fi
fi

echo 'All files processed. Have a nice day!' >&2
ap_exit ${ap_exit_code-0}

# END CORE
